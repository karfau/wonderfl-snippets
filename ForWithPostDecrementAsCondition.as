//look at the comments in the code package {	import flash.accessibility.Accessibility;    import flash.display.Sprite;    import flash.events.*;    import flash.text.TextField;        public class TraceTest extends Sprite {                public function TraceTest() {                        inittrace(stage);                        var i:int = -1;            var test:Array = ["a","b","c"];                        trace("given test is [",test,"]");            //But how strange is this:            trace("for (var i:int = test.length; i--; ){ prints:");            for (i = test.length; i--; ){            		trace(test[i]);            	}            /*            from the AS-docs of for:            for ([init]; [condition]; [next]) { 				[statement-block]			}                        Of course: the condition is executed before             each statement-block, wich decrements it,             as if we would have put the same statement            to [next].            My first idea was that we would need to write             for (var i:int = test.length; --i; ){            	if this should work at all.            	but see what happens:*/            	            trace("for (var i:int = test.length; --i; ){ prints:");            for (i = test.length; --i; ){            		trace(test[i]);            	}            	/*            	lets take a closer look at what happens in             	the first for-loop:             	format:                           1) [init] var i:int = test.tength // i is 3             2) [condition]{             3)   Boolean(i)// i is 3 -> true             4)	 i= i-1 // i is 2             5) }             6) [statement-block] / [next] // i is 2 (==test.length-1)             7) [condition]{             8)   Boolean(i)// i is 2 -> true             9)	 i= i-1 // i is 1            10) }            11) [statement-block] / [next] // i is 1             7) [condition]{             8)   Boolean(i)// i is 1 -> true             9)	 i= i-1 // i is 0            10) }            11) [statement-block] / [next] // i is 0             7) [condition]{             8)   Boolean(i)// i is 0 -> FALSE             9)	 i= i-1 // i is -1            10) }            			So there are two thing that wake this work:			A) the condition is tested against a value 			of i that is not the same as inside the 			statement-block. 			(it is decremented AFTER the condition!)			B) Boolean(0) == false						So it looks strange at first,			but looking at this: it would be strange			if it wouldn't work.						Thanks to the inspiration through			Robert Penner's			http://github.com/robertpenner/as3-signals/blob/master/src/org/osflash/signals/Signal.as			inside of 			protected function setValueClasses(...) and elsewhere						As he stated it in a very simple way:							>Yes, it's equivalent to:			>			>var i:int = _valueClasses.length;			>while (i--){			>			*/            				/*			some tests started out of confusion:			var x:int = 1;            trace("if x == 1 then Boolean(x--) is",Boolean(x--));            x=1;            trace("if x == 1 then Boolean(--x) is",Boolean(--x));            */        }            }}/////  WONDERFL TRACE /////import flash.display.Sprite;import flash.display.Stage;import flash.text.TextField;import flash.text.TextFormat;function inittrace(s:Stage):void{    WTrace.initTrace(s);}//global trace functionvar trace:Function;//wtreace classclass WTrace{        private static var FONT:String = "Fixedsys";        private static var SIZE:Number = 12;        private static var TextFields:Array = [];        private static var trace_stage:Stage;                public static function initTrace(stg:Stage):void        {            trace_stage = stg;            trace = wtrace;        }                private static function scrollup():void        {            // maximum number of lines: 100            if (TextFields.length > 100)             {                var removeme:TextField = TextFields.shift();                trace_stage.removeChild(removeme);                removeme = null;            }            for(var x:Number=0;x<TextFields.length;x++)            {                (TextFields[x] as TextField).y -= SIZE*1.2;            }        }            public static function wtrace(... args):void        {                    var s:String="";            var tracefield:TextField;                        for (var i:int;i < args.length;i++)            {                // imitating flash:                // putting a space between the parameters                if (i != 0) s+=" ";                s+=args[i].toString();            }                        tracefield= new TextField();            tracefield.autoSize = "left";            tracefield.text = s;            tracefield.y = trace_stage.stageHeight - 20;            var tf:TextFormat = new TextFormat(FONT, SIZE);            tracefield.setTextFormat(tf);            trace_stage.addChild(tracefield);            scrollup();                                  TextFields.push(tracefield);                    }}